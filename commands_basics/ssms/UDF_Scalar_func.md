
# **User Defined Functions (UDFs) in SQL Server — with Focus on Scalar Functions**

### **1. Introduction**

In SQL Server, a **User Defined Function (UDF)** is a programmable routine created by users to encapsulate reusable logic that can be invoked within queries, views, or stored procedures.
UDFs promote **code reusability**, **modularity**, and **consistency**, especially for calculations and formatting that occur repeatedly across queries.

Unlike system-defined functions such as `GETDATE()` or `ABS()`, user-defined functions allow you to implement custom business or computational logic directly inside the database engine.

---

### **2. Types of User Defined Functions**

| **Type**                                         | **Description**                                                          | **Return Type**                         |
| ------------------------------------------------ | ------------------------------------------------------------------------ | --------------------------------------- |
| **Scalar Function**                              | Returns a single scalar value. Used for calculations or transformations. | Scalar (e.g., `INT`, `VARCHAR`, `DATE`) |
| **Inline Table-Valued Function (iTVF)**          | Returns a table generated by a single `SELECT` statement.                | Table                                   |
| **Multi-Statement Table-Valued Function (mTVF)** | Returns a table constructed using multiple T-SQL statements.             | Table                                   |

This article focuses on **Scalar Functions**, which form the foundation for reusable, formula-based logic.

---

### **3. Understanding Scalar Functions**

A **Scalar Function**:

* Accepts zero or more input parameters.
* Returns a single value of a scalar data type.
* Performs logic without modifying database data.
* Cannot return `text`, `ntext`, `image`, `cursor`, or `timestamp` types.

#### **Syntax**

```sql
CREATE FUNCTION [schema_name].[function_name]
(
    [@parameter_name] [datatype] [= default_value],
    ...
)
RETURNS [return_datatype]
AS
BEGIN
    -- Function body
    RETURN [value]
END
```

---

### **4. Example: Basic Scalar Function**

```sql
CREATE FUNCTION dbo.CalculateAge(@DOB DATE)
RETURNS INT
AS
BEGIN
    DECLARE @Age INT;
    SET @Age = DATEDIFF(YEAR, @DOB, GETDATE()) 
               - CASE 
                    WHEN (MONTH(@DOB) > MONTH(GETDATE())) 
                      OR (MONTH(@DOB) = MONTH(GETDATE()) AND DAY(@DOB) > DAY(GETDATE())) 
                    THEN 1 ELSE 0 
                 END;
    RETURN @Age;
END;
```

This function calculates the age of an employee based on their date of birth (`@DOB`).

---

### **5. Executing Scalar Functions**

After creation, scalar functions appear under:

```
Database → Programmability → Functions → Scalar-valued Functions
```

#### **Example: Execution**

```sql
SELECT dbo.CalculateAge('1982-10-08') AS Age;
```

#### **Schema Name Requirement**

Always qualify your function with the **schema name** (commonly `dbo`) for clarity and performance.

A **schema** is a logical container within a database—not the database itself.
Example: `Database → Schema (dbo/hr/finance) → Function/Table/Procedure`

To call a function from another database:

```sql
SELECT HRDB.dbo.CalculateAge('1982-10-08');
```

---

### **6. Using Scalar Functions in Queries**

Scalar functions can be directly used within SQL clauses.

| **Clause** | **Example**                                                 | **Purpose**            |
| ---------- | ----------------------------------------------------------- | ---------------------- |
| **SELECT** | `SELECT Name, dbo.CalculateAge(DOB) AS Age FROM Employees;` | Compute derived values |
| **WHERE**  | `SELECT * FROM Employees WHERE dbo.CalculateAge(DOB) > 30;` | Apply filters          |
| **HAVING** | `HAVING dbo.GetBonus(Dept) > 5000;`                         | Aggregate filtering    |

---

### **7. Modifying or Deleting Functions**

| **Action**          | **Syntax Example**                     |
| ------------------- | -------------------------------------- |
| **Modify Function** | `ALTER FUNCTION dbo.CalculateAge ...`  |
| **Delete Function** | `DROP FUNCTION dbo.CalculateAge;`      |
| **View Definition** | `EXEC sp_helptext 'dbo.CalculateAge';` |

---

### **8. Best Practices for Scalar Functions**

1. Always use schema-qualified names (`dbo.FunctionName`).
2. Keep logic simple and formula-oriented.
3. Avoid data modification statements (INSERT/UPDATE/DELETE).
4. Be careful when using scalar functions in large datasets—they execute row by row.
5. Use them for reusable **calculation logic**, such as formatting, tax or bonus computation, and data transformations.

---

### **9. Summary**

| **Aspect**            | **Scalar Function**                             |
| --------------------- | ----------------------------------------------- |
| **Purpose**           | Perform calculations and return one value.      |
| **Return Type**       | Single scalar value (e.g., `INT`, `VARCHAR`).   |
| **Data Modification** | Not permitted.                                  |
| **Usage Scope**       | Within `SELECT`, `WHERE`, and `HAVING` clauses. |
| **Performance**       | Evaluated row by row; can impact large queries. |
| **Modularity Type**   | Formula-based logic encapsulation.              |

---

### **10. Conclusion**

**User Defined Functions** are integral to writing modular and maintainable SQL code.
Among them, **Scalar Functions** enable developers to encapsulate **formula-based logic** into self-contained, reusable units that integrate seamlessly with queries.

By adopting UDFs effectively—using schema qualification, lightweight logic, and proper context—developers can achieve high consistency, simplified maintenance, and improved readability across SQL Server projects.


