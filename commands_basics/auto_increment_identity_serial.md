
# **Identity Columns and Retrieving Generated Keys in SQL (Cross-Database Guide)**

## **1. What Is an Identity Column?**

An **identity column** (also called an *auto-increment* or *serial* column) is a numeric column that automatically generates a unique sequential value whenever a new record is inserted into a table.

It’s most commonly used for **primary keys**, ensuring that each record has a unique identifier without requiring manual input.

### **Key Characteristics**

* Automatically increases for each new row.
* Usually starts from a **seed** (default 1).
* Can have a custom **increment** value.
* Automatically ensures **uniqueness** (often used as `PRIMARY KEY`).

---

## **2. Creating Identity (Auto-Increment) Columns Across SQL Databases**

| Database            | Syntax for Auto-Increment Column                     |
| ------------------- | ---------------------------------------------------- |
| **SQL Server**      | `INT IDENTITY(1,1)`                                  |
| **MySQL / MariaDB** | `INT AUTO_INCREMENT`                                 |
| **PostgreSQL**      | `SERIAL` or `GENERATED ALWAYS AS IDENTITY`           |
| **SQLite**          | `INTEGER PRIMARY KEY AUTOINCREMENT`                  |
| **Oracle**          | `GENERATED ALWAYS AS IDENTITY` or using a `SEQUENCE` |

### **Example (Generalized SQL)**

```sql
CREATE TABLE Customers (
    CustomerID INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    Name VARCHAR(100),
    Email VARCHAR(100)
);
```

In older systems (like Oracle pre-12c), this was done manually using **sequences** and **triggers**, e.g.:

```sql
CREATE SEQUENCE customer_seq START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER trg_customer_id
BEFORE INSERT ON Customers
FOR EACH ROW
BEGIN
  SELECT customer_seq.NEXTVAL INTO :new.CustomerID FROM dual;
END;
```

---

## **3. Retrieving the Last Generated Identity Value**

Every SQL system provides a way to retrieve the **auto-generated identity value** after an insert operation —
but they differ slightly in how they handle *scope*, *session*, and *table*.

---

### **(A) SQL Server**

| Function                 | Description                                              |
| ------------------------ | -------------------------------------------------------- |
| `SCOPE_IDENTITY()`       | Last identity in same session and same scope.            |
| `@@IDENTITY`             | Last identity in same session (any scope).               |
| `IDENT_CURRENT('table')` | Last identity for a specific table, across all sessions. |

---

### **(B) MySQL / MariaDB**

MySQL uses a much simpler model.

#### **Function**

```sql
SELECT LAST_INSERT_ID();
```

#### **Description**

* Returns the last automatically generated value for an `AUTO_INCREMENT` column.
* The value is **per-connection** — safe in multi-user environments.
* Works even when multiple tables have auto-increment columns.

#### **Example**

```sql
INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@example.com');
SELECT LAST_INSERT_ID();
```

✅ Equivalent to SQL Server’s **`SCOPE_IDENTITY()`** — safe and session-specific.

---

### **(C) PostgreSQL**

PostgreSQL traditionally uses the `SERIAL` data type (which internally uses sequences),
but since version 10+, it also supports the SQL-standard `IDENTITY` columns.

#### **Option 1 — Using `SERIAL`**

```sql
CREATE TABLE Orders (
    OrderID SERIAL PRIMARY KEY,
    CustomerName VARCHAR(100)
);
```

To get the last generated value:

```sql
INSERT INTO Orders (CustomerName) VALUES ('Bob');
SELECT currval(pg_get_serial_sequence('Orders', 'OrderID'));
```

* `currval()` gives the **most recent sequence value** generated **in the same session**.
* It’s safe — it won’t be affected by other users’ inserts.

#### **Option 2 — Using `RETURNING` Clause (Preferred Modern Way)**

```sql
INSERT INTO Orders (CustomerName)
VALUES ('Alice')
RETURNING OrderID;
```

✅ This returns the identity value **immediately**, no extra query needed.
Equivalent to SQL Server’s `OUTPUT INSERTED.ID` or `SCOPE_IDENTITY()`.

---

### **(D) SQLite**

SQLite’s identity mechanism is simple — any column declared as `INTEGER PRIMARY KEY` is an alias for the row’s unique ID.

#### **Retrieving Last Inserted ID**

```sql
SELECT last_insert_rowid();
```

* Session-specific (safe in multi-user environments).
* Works only for the connection that performed the insert.

✅ Equivalent to MySQL’s `LAST_INSERT_ID()` and SQL Server’s `SCOPE_IDENTITY()`.

---

### **(E) Oracle**

Before Oracle 12c, you had to use **sequences** explicitly.
From 12c onward, Oracle supports **identity columns**.

#### **Modern Oracle Example**

```sql
CREATE TABLE Products (
    ProductID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ProductName VARCHAR2(100)
);

INSERT INTO Products (ProductName) VALUES ('Laptop')
RETURNING ProductID INTO :id;
```

* The `RETURNING INTO` clause returns the newly generated identity.
  ✅ Equivalent to PostgreSQL’s `RETURNING` and SQL Server’s `OUTPUT INSERTED`.

#### **Classic (Pre-12c) Oracle**

Manually using a sequence:

```sql
INSERT INTO Products (ProductID, ProductName)
VALUES (product_seq.NEXTVAL, 'Laptop');

SELECT product_seq.CURRVAL FROM dual;
```

---

## **4. Cross-Database Comparison**

| Database       | Create Identity                     | Retrieve Last Identity     | Safe Across Sessions | Modern Equivalent     |
| -------------- | ----------------------------------- | -------------------------- | -------------------- | --------------------- |
| **SQL Server** | `IDENTITY(1,1)`                     | `SCOPE_IDENTITY()`         | ✅ Yes                | `OUTPUT INSERTED.ID`  |
| **MySQL**      | `AUTO_INCREMENT`                    | `LAST_INSERT_ID()`         | ✅ Yes                | `LAST_INSERT_ID()`    |
| **PostgreSQL** | `SERIAL` / `IDENTITY`               | `RETURNING` or `currval()` | ✅ Yes                | `RETURNING`           |
| **SQLite**     | `INTEGER PRIMARY KEY AUTOINCREMENT` | `last_insert_rowid()`      | ✅ Yes                | `last_insert_rowid()` |
| **Oracle**     | `GENERATED AS IDENTITY`             | `RETURNING INTO`           | ✅ Yes                | `RETURNING INTO`      |

---

## **5. Best Practices**

1. **Always retrieve identity within the same transaction or session.**
   This ensures you get the value generated by *your own* insert.

2. **Use `RETURNING` or equivalent if supported.**
   These are atomic — they return the identity in the same operation, preventing race conditions.

3. **Avoid querying the table’s max ID manually (`SELECT MAX(ID)`)**.
   It can return incorrect results in multi-user environments.

4. **Use identity columns for surrogate keys, not business logic.**
   They are technical identifiers — not meaningful domain data.

---

## **6. Summary**

| Concept                    | SQL Server                       | MySQL              | PostgreSQL                               | SQLite                | Oracle                  |
| -------------------------- | -------------------------------- | ------------------ | ---------------------------------------- | --------------------- | ----------------------- |
| **Auto increment syntax**  | `IDENTITY(1,1)`                  | `AUTO_INCREMENT`   | `SERIAL` / `IDENTITY`                    | `AUTOINCREMENT`       | `GENERATED AS IDENTITY` |
| **Get last ID (safe)**     | `SCOPE_IDENTITY()`               | `LAST_INSERT_ID()` | `RETURNING` / `currval()`                | `last_insert_rowid()` | `RETURNING INTO`        |
| **Unsafe / global method** | `@@IDENTITY` / `IDENT_CURRENT()` | —                  | `lastval()` across all sessions (unsafe) | —                     | —                       |

---

## **7. Conclusion**

While SQL Server provides three distinct functions for identity retrieval (`SCOPE_IDENTITY()`, `@@IDENTITY`, `IDENT_CURRENT()`),
the **core concept** is consistent across all SQL systems:
each database maintains a mechanism to **generate unique auto-incremented values** and to **safely retrieve the most recent one**.

For modern applications:

* Prefer **atomic retrieval** (`RETURNING`, `OUTPUT`, or similar).
* Avoid **global or cross-session functions** unless explicitly needed.
* Treat identity columns as **internal technical keys**, not business identifiers.

